<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gallium.cli.core API documentation</title>
<meta name="description" content="This module is designed to speed up the development of command line apps without needing to specify arguments. The
arguments will be defined based on â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gallium.cli.core</code></h1>
</header>
<section id="section-intro">
<p>This module is designed to speed up the development of command line apps without needing to specify arguments. The
arguments will be defined based on the signature of the decorated methods used to handle the command line input.</p>
<h2 id="quick-start">Quick start</h2>
<p>You can use the default <code><a title="gallium.cli.core.console" href="#gallium.cli.core.console">console</a></code> from <code><a title="gallium.cli.core" href="#gallium.cli.core">gallium.cli.core</a></code> or create your own.</p>
<p>For example, create <code>app.py</code> with the following source code.</p>
<pre><code class="language-python">from gallium.cli.core import console

@console.command([&quot;set&quot;, &quot;config&quot;])
def set_config(name: str):
    ''' Example to humanized command '''
    print(name)

@console.command(&quot;auth&quot;)
def authenticate(name: str):
    ''' Example to humanized command '''
    print(name)

@console.simple_command
def add(a: int, b: int):
    print(a + b)

console.run_with()
</code></pre>
<p>Then, you should be able to call <code>set_config</code>, <code>authenticate</code>, and <code>add</code> by invoking:</p>
<ul>
<li><code>python3 app.py set config --name panda</code></li>
<li><code>python3 app.py auth --name foo</code></li>
<li><code>python3 app.py add --a 1 --b 2</code></li>
</ul>
<p>respectively.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module is designed to speed up the development of command line apps without needing to specify arguments. The
arguments will be defined based on the signature of the decorated methods used to handle the command line input.

## Quick start

You can use the default `console` from `gallium.cli.core` or create your own.

For example, create `app.py` with the following source code.

```python
from gallium.cli.core import console

@console.command([&#34;set&#34;, &#34;config&#34;])
def set_config(name: str):
    &#39;&#39;&#39; Example to humanized command &#39;&#39;&#39;
    print(name)

@console.command(&#34;auth&#34;)
def authenticate(name: str):
    &#39;&#39;&#39; Example to humanized command &#39;&#39;&#39;
    print(name)

@console.simple_command
def add(a: int, b: int):
    print(a + b)

console.run_with()
```

Then, you should be able to call `set_config`, `authenticate`, and `add` by invoking:

* `python3 app.py set config --name panda`
* `python3 app.py auth --name foo`
* `python3 app.py add --a 1 --b 2`

respectively.

&#34;&#34;&#34;
import importlib
import inspect
import logging
import re
from argparse import ArgumentParser
from typing import List, Optional, Callable, Union, Any, Dict, Type

from imagination.debug import get_logger

from gallium.obj.utils import is_optional, get_all_types


class Command:
    &#34;&#34;&#34; Command Metadata &#34;&#34;&#34;
    def __init__(self, id: List[str], callable: Callable, description: Optional[str] = None):
        if len(id) == 0:
            raise ValueError(f&#39;The command ID must be defined for {callable}.&#39;)

        self.__id = id
        self.__callable = callable
        self.__description = description

    @property
    def id(self) -&gt; List[str]:
        return self.__id

    @property
    def description(self) -&gt; Optional[str]:
        return self.__description

    @property
    def callable(self) -&gt; Callable:
        return self.__callable

    def __repr__(self):
        return f&#39;{type(self).__name__}({self.__callable.__module__}.{self.__callable.__name__})&#39;

    def __str__(self):
        return f&#39;{type(self).__name__}({self.__callable.__module__}.{self.__callable.__name__})&#39;


class Console:
    &#34;&#34;&#34; Console (Argument Parser Wrapper) &#34;&#34;&#34;
    __SPECIAL_PARSER_KEY_FOR_COMMAND = &#39;_command&#39;

    def __init__(self):
        self.__commands: List[Command] = list()
        self.__log = get_logger(type(self).__name__, logging.INFO)

    def command(self, id: Union[None, str, List[str]] = None, description: Optional[str] = None):
        &#34;&#34;&#34; A decorator to define a command

            .. warning:: This only works on static methods or functions.
        &#34;&#34;&#34;
        def inner(_func: Callable):
            actual_id = (re.split(r&#39;\s+&#39;, id) if isinstance(id, str) else id) if id else [_func.__name__]
            self.__commands.append(Command(actual_id,
                                           _func,
                                           (description or _func.__doc__ or &#39;&#39;).lstrip()))
            return _func
        return inner

    def simple_command(self, _func: Callable):
        self.__commands.append(Command([_func.__name__],
                                       _func,
                                       (_func.__doc__ or &#39;&#39;).lstrip()))
        return _func

    def run_with(self, *import_paths):
        for import_path in import_paths:
            importlib.import_module(import_path)
        parser_map = dict()
        for command in self.__commands:
            self.__compute_graph(command, parser_map, command.id)
        parser = ArgumentParser()
        self.__initialize_parser(parser, parser_map)
        args = parser.parse_args()

        params = {
            k: v
            for k, v in vars(args).items()
            if k not in (&#39;func&#39;, &#39;origin_&#39;)
        }

        if hasattr(args, &#39;origin_&#39;):
            command: Command = args.origin_
            self.__log.debug(&#39;command: %s -&gt; %s (begin)&#39;, command, params)
            command.callable(**params)
            self.__log.debug(&#39;command: %s -&gt; %s (end)&#39;, command, params)
        else:
            self.__log.error(&#39;Unable to process&#39;)
            parser.print_help()

    def __compute_graph(self, command, node: Dict[str, Any], id_trail: List[str]):
        command_block_name = id_trail[0]
        if command_block_name not in node:
            node[command_block_name] = dict()
        if len(id_trail) == 1:
            if self.__SPECIAL_PARSER_KEY_FOR_COMMAND in node[command_block_name]:
                already_registered_command = node[command_block_name][self.__SPECIAL_PARSER_KEY_FOR_COMMAND]
                raise RuntimeError(f&#39;The command ID &#34;{&#34; &#34;.join(command.id)}&#34; has already been defined for {already_registered_command}&#39;)
            else:
                node[command_block_name][self.__SPECIAL_PARSER_KEY_FOR_COMMAND] = command
        else:
            self.__compute_graph(command, node[command_block_name], id_trail[1:])

    def __initialize_parser(self, parser: ArgumentParser, parser_map: Dict[str, Any], prefix_trail: Optional[List[str]] = None):
        prefix_trail = prefix_trail or list()
        subparsers = parser.add_subparsers()

        if self.__SPECIAL_PARSER_KEY_FOR_COMMAND in parser_map:
            # Define the registered command
            command: Command = parser_map[self.__SPECIAL_PARSER_KEY_FOR_COMMAND]
            parser.description = command.description
            parser.set_defaults(
                origin_=command,
                func=command.callable
            )
            self.__define_arguments(parser, command)
        else:
            # Define the default command (to provide sublisting)
            parser.set_defaults(func=lambda: parser.print_help())

        for sub_command_name, subparser_map in parser_map.items():
            if sub_command_name != self.__SPECIAL_PARSER_KEY_FOR_COMMAND:
                self.__initialize_parser(
                    subparsers.add_parser(sub_command_name),
                    subparser_map,
                    prefix_trail + [sub_command_name]
                )

    def __define_arguments(self, parser: ArgumentParser, command: Command):
        &#34;&#34;&#34; Define the command line argument based on the reflection of the callable.

            .. warning:: This does not support instance methods at the moment.
        &#34;&#34;&#34;
        signature = inspect.signature(command.callable)
        for parameter_name, parameter in signature.parameters.items():
            self.__define_argument(parser, &#39; &#39;.join(command.id), parameter_name, parameter)

    def __define_argument(self, parser: ArgumentParser, command_name: str, parameter_name: str, parameter: inspect.Parameter):
        &#34;&#34;&#34; Define the command line argument according to the given parameter

            .. warning:: This is still incomplete in term of handling any combination of type hints.
        &#34;&#34;&#34;
        name = f&#39;--{re.sub(&#34;_&#34;, &#34;-&#34;, parameter_name)}&#39;
        parameter_type = None
        required = True

        annotation = parameter.annotation

        # Determine whether the parameter is option.
        if hasattr(annotation, &#34;__origin__&#34;):
            annotated_type = getattr(annotation, &#34;__origin__&#34;)
            required = is_optional(annotation)
            parameter_type = get_all_types(annotation)[0]

        if not parameter_type:
            parameter_type = annotation if annotation != inspect._empty else str

        description = f&#34;{&#39;&#39; if required else &#39;[Optional] &#39;}({parameter_type}) {re.sub(&#39;_+&#39;, &#39; &#39;, parameter_name)}&#34;

        parser.add_argument(name, type=parameter_type, required=required, help=description)


console: Console = Console()
&#34;&#34;&#34; Default/Standalone Console &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="gallium.cli.core.console"><code class="name">var <span class="ident">console</span> :Â <a title="gallium.cli.core.Console" href="#gallium.cli.core.Console">Console</a></code></dt>
<dd>
<div class="desc"><p>Default/Standalone Console</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gallium.cli.core.Command"><code class="flex name class">
<span>class <span class="ident">Command</span></span>
<span>(</span><span>id:Â List[str], callable:Â Callable, description:Â Union[str,Â NoneType]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Command:
    &#34;&#34;&#34; Command Metadata &#34;&#34;&#34;
    def __init__(self, id: List[str], callable: Callable, description: Optional[str] = None):
        if len(id) == 0:
            raise ValueError(f&#39;The command ID must be defined for {callable}.&#39;)

        self.__id = id
        self.__callable = callable
        self.__description = description

    @property
    def id(self) -&gt; List[str]:
        return self.__id

    @property
    def description(self) -&gt; Optional[str]:
        return self.__description

    @property
    def callable(self) -&gt; Callable:
        return self.__callable

    def __repr__(self):
        return f&#39;{type(self).__name__}({self.__callable.__module__}.{self.__callable.__name__})&#39;

    def __str__(self):
        return f&#39;{type(self).__name__}({self.__callable.__module__}.{self.__callable.__name__})&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gallium.cli.core.Command.callable"><code class="name">var <span class="ident">callable</span> :Â Callable</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def callable(self) -&gt; Callable:
    return self.__callable</code></pre>
</details>
</dd>
<dt id="gallium.cli.core.Command.description"><code class="name">var <span class="ident">description</span> :Â Union[str,Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; Optional[str]:
    return self.__description</code></pre>
</details>
</dd>
<dt id="gallium.cli.core.Command.id"><code class="name">var <span class="ident">id</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; List[str]:
    return self.__id</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gallium.cli.core.Console"><code class="flex name class">
<span>class <span class="ident">Console</span></span>
</code></dt>
<dd>
<div class="desc"><p>Console (Argument Parser Wrapper)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Console:
    &#34;&#34;&#34; Console (Argument Parser Wrapper) &#34;&#34;&#34;
    __SPECIAL_PARSER_KEY_FOR_COMMAND = &#39;_command&#39;

    def __init__(self):
        self.__commands: List[Command] = list()
        self.__log = get_logger(type(self).__name__, logging.INFO)

    def command(self, id: Union[None, str, List[str]] = None, description: Optional[str] = None):
        &#34;&#34;&#34; A decorator to define a command

            .. warning:: This only works on static methods or functions.
        &#34;&#34;&#34;
        def inner(_func: Callable):
            actual_id = (re.split(r&#39;\s+&#39;, id) if isinstance(id, str) else id) if id else [_func.__name__]
            self.__commands.append(Command(actual_id,
                                           _func,
                                           (description or _func.__doc__ or &#39;&#39;).lstrip()))
            return _func
        return inner

    def simple_command(self, _func: Callable):
        self.__commands.append(Command([_func.__name__],
                                       _func,
                                       (_func.__doc__ or &#39;&#39;).lstrip()))
        return _func

    def run_with(self, *import_paths):
        for import_path in import_paths:
            importlib.import_module(import_path)
        parser_map = dict()
        for command in self.__commands:
            self.__compute_graph(command, parser_map, command.id)
        parser = ArgumentParser()
        self.__initialize_parser(parser, parser_map)
        args = parser.parse_args()

        params = {
            k: v
            for k, v in vars(args).items()
            if k not in (&#39;func&#39;, &#39;origin_&#39;)
        }

        if hasattr(args, &#39;origin_&#39;):
            command: Command = args.origin_
            self.__log.debug(&#39;command: %s -&gt; %s (begin)&#39;, command, params)
            command.callable(**params)
            self.__log.debug(&#39;command: %s -&gt; %s (end)&#39;, command, params)
        else:
            self.__log.error(&#39;Unable to process&#39;)
            parser.print_help()

    def __compute_graph(self, command, node: Dict[str, Any], id_trail: List[str]):
        command_block_name = id_trail[0]
        if command_block_name not in node:
            node[command_block_name] = dict()
        if len(id_trail) == 1:
            if self.__SPECIAL_PARSER_KEY_FOR_COMMAND in node[command_block_name]:
                already_registered_command = node[command_block_name][self.__SPECIAL_PARSER_KEY_FOR_COMMAND]
                raise RuntimeError(f&#39;The command ID &#34;{&#34; &#34;.join(command.id)}&#34; has already been defined for {already_registered_command}&#39;)
            else:
                node[command_block_name][self.__SPECIAL_PARSER_KEY_FOR_COMMAND] = command
        else:
            self.__compute_graph(command, node[command_block_name], id_trail[1:])

    def __initialize_parser(self, parser: ArgumentParser, parser_map: Dict[str, Any], prefix_trail: Optional[List[str]] = None):
        prefix_trail = prefix_trail or list()
        subparsers = parser.add_subparsers()

        if self.__SPECIAL_PARSER_KEY_FOR_COMMAND in parser_map:
            # Define the registered command
            command: Command = parser_map[self.__SPECIAL_PARSER_KEY_FOR_COMMAND]
            parser.description = command.description
            parser.set_defaults(
                origin_=command,
                func=command.callable
            )
            self.__define_arguments(parser, command)
        else:
            # Define the default command (to provide sublisting)
            parser.set_defaults(func=lambda: parser.print_help())

        for sub_command_name, subparser_map in parser_map.items():
            if sub_command_name != self.__SPECIAL_PARSER_KEY_FOR_COMMAND:
                self.__initialize_parser(
                    subparsers.add_parser(sub_command_name),
                    subparser_map,
                    prefix_trail + [sub_command_name]
                )

    def __define_arguments(self, parser: ArgumentParser, command: Command):
        &#34;&#34;&#34; Define the command line argument based on the reflection of the callable.

            .. warning:: This does not support instance methods at the moment.
        &#34;&#34;&#34;
        signature = inspect.signature(command.callable)
        for parameter_name, parameter in signature.parameters.items():
            self.__define_argument(parser, &#39; &#39;.join(command.id), parameter_name, parameter)

    def __define_argument(self, parser: ArgumentParser, command_name: str, parameter_name: str, parameter: inspect.Parameter):
        &#34;&#34;&#34; Define the command line argument according to the given parameter

            .. warning:: This is still incomplete in term of handling any combination of type hints.
        &#34;&#34;&#34;
        name = f&#39;--{re.sub(&#34;_&#34;, &#34;-&#34;, parameter_name)}&#39;
        parameter_type = None
        required = True

        annotation = parameter.annotation

        # Determine whether the parameter is option.
        if hasattr(annotation, &#34;__origin__&#34;):
            annotated_type = getattr(annotation, &#34;__origin__&#34;)
            required = is_optional(annotation)
            parameter_type = get_all_types(annotation)[0]

        if not parameter_type:
            parameter_type = annotation if annotation != inspect._empty else str

        description = f&#34;{&#39;&#39; if required else &#39;[Optional] &#39;}({parameter_type}) {re.sub(&#39;_+&#39;, &#39; &#39;, parameter_name)}&#34;

        parser.add_argument(name, type=parameter_type, required=required, help=description)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gallium.cli.core.Console.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, id:Â Union[NoneType,Â str,Â List[str]]Â =Â None, description:Â Union[str,Â NoneType]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator to define a command</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;This only works on static methods or functions.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(self, id: Union[None, str, List[str]] = None, description: Optional[str] = None):
    &#34;&#34;&#34; A decorator to define a command

        .. warning:: This only works on static methods or functions.
    &#34;&#34;&#34;
    def inner(_func: Callable):
        actual_id = (re.split(r&#39;\s+&#39;, id) if isinstance(id, str) else id) if id else [_func.__name__]
        self.__commands.append(Command(actual_id,
                                       _func,
                                       (description or _func.__doc__ or &#39;&#39;).lstrip()))
        return _func
    return inner</code></pre>
</details>
</dd>
<dt id="gallium.cli.core.Console.run_with"><code class="name flex">
<span>def <span class="ident">run_with</span></span>(<span>self, *import_paths)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_with(self, *import_paths):
    for import_path in import_paths:
        importlib.import_module(import_path)
    parser_map = dict()
    for command in self.__commands:
        self.__compute_graph(command, parser_map, command.id)
    parser = ArgumentParser()
    self.__initialize_parser(parser, parser_map)
    args = parser.parse_args()

    params = {
        k: v
        for k, v in vars(args).items()
        if k not in (&#39;func&#39;, &#39;origin_&#39;)
    }

    if hasattr(args, &#39;origin_&#39;):
        command: Command = args.origin_
        self.__log.debug(&#39;command: %s -&gt; %s (begin)&#39;, command, params)
        command.callable(**params)
        self.__log.debug(&#39;command: %s -&gt; %s (end)&#39;, command, params)
    else:
        self.__log.error(&#39;Unable to process&#39;)
        parser.print_help()</code></pre>
</details>
</dd>
<dt id="gallium.cli.core.Console.simple_command"><code class="name flex">
<span>def <span class="ident">simple_command</span></span>(<span>self, _func:Â Callable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_command(self, _func: Callable):
    self.__commands.append(Command([_func.__name__],
                                   _func,
                                   (_func.__doc__ or &#39;&#39;).lstrip()))
    return _func</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#quick-start">Quick start</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gallium.cli" href="index.html">gallium.cli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="gallium.cli.core.console" href="#gallium.cli.core.console">console</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gallium.cli.core.Command" href="#gallium.cli.core.Command">Command</a></code></h4>
<ul class="">
<li><code><a title="gallium.cli.core.Command.callable" href="#gallium.cli.core.Command.callable">callable</a></code></li>
<li><code><a title="gallium.cli.core.Command.description" href="#gallium.cli.core.Command.description">description</a></code></li>
<li><code><a title="gallium.cli.core.Command.id" href="#gallium.cli.core.Command.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gallium.cli.core.Console" href="#gallium.cli.core.Console">Console</a></code></h4>
<ul class="">
<li><code><a title="gallium.cli.core.Console.command" href="#gallium.cli.core.Console.command">command</a></code></li>
<li><code><a title="gallium.cli.core.Console.run_with" href="#gallium.cli.core.Console.run_with">run_with</a></code></li>
<li><code><a title="gallium.cli.core.Console.simple_command" href="#gallium.cli.core.Console.simple_command">simple_command</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>